<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis数据结构汇总</title>
      <link href="/posts/21642.html"/>
      <url>/posts/21642.html</url>
      
        <content type="html"><![CDATA[<p><strong>关于key：</strong></p><p><strong>1.key不要太长</strong>，尽量不要超过1024字节，这不仅消耗内存，而且会<strong>降低查找的效率</strong>；</p><p><strong>2.key</strong>也不要太短，太短的话，key的 <strong>可读性会降低</strong>；</p><p>3.在一个项目中，key最好使用<strong>统一的命名</strong>模式，例如user:10000:passwd。</p><p><img src="https://img-blog.csdnimg.cn/a27425f4b5314e018913a10a4e1c34ce.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5piv55yf55qE6I-c5ZWK5ZWK,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h1 id="1-字符串-String终究是我扛下了所有-："><a href="#1-字符串-String终究是我扛下了所有-：" class="headerlink" title="1.字符串(String终究是我扛下了所有)："></a><strong>1.字符串(String终究是我扛下了所有)：</strong></h1><p>redis中的键都是字符串对象，而且其他几种数据结构都是在字符串对象基础上构建的。字符串对象的值可以是<strong>字符串(Json/XML)、数字(int/double等)或二进制(图片视频音频等)<strong>，最大不能超过512MB。字符串对象的内部编码有3种 ：</strong>int(字符串对象保存的是int ,并且可以用long表示)、raw(字符串对象保存的字符串值长度&gt;32字节)和embstr(&lt;=32字节)<strong>。Redis会根据当前</strong>值的类型和长度</strong>来决定使用哪种编码来实现。</p><p><img src="https://img-blog.csdnimg.cn/6ce8895892354b70bbe13ac1b8140a51.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5piv55yf55qE6I-c5ZWK5ZWK,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p><strong>应用场景：</strong></p><p><strong>①Redis经常作为缓存层</strong>，<strong>来缓存热点数据</strong>。先去redis读取，没有再去数据库。不过要注意一些问题：缓存穿透、雪崩以及缓存更新问题等。</p><p><strong>②计数器：</strong>经常可以被用来做计数器，如微博的评论数、点赞数、分享数，抖音作品的收藏数，京东商品的销售量、评价数等。<strong>限速器：</strong>如验证码接口访问频率限制，会限制用户每分钟获取验证码的频率。<strong>分布式ID：</strong>由于Redis自增自减操作的原子性，也经常在分布式系统中用来生成唯一的订单号、序列号等。</p><p>**③分布式系统共享session:**用户的请求可能分发到不同的服务器上，从而导致用户登录保存Session是在一台服务器上，而读取Session是在另一台服务器上因此会读不到Session。</p><p><strong>④二进制数据的存储</strong>(图片视频音频等)。</p><h1 id="2-列表-List栈和队列我都行-："><a href="#2-列表-List栈和队列我都行-：" class="headerlink" title="2.列表(List栈和队列我都行)："></a><strong>2.列表(List栈和队列我都行)：</strong></h1><p>存储一组有序的、可重复的数据。因<strong>有序性</strong>，它可以获取指定范围的列表元素，<strong>可以0(1)时间复杂度获取指定索引下标的元素。</strong></p><p>①当列表的<strong>元素个数&lt;512</strong>并且每个元素的<strong>值&lt;64字节</strong>时: List对象使用ziplist(压缩列表)数据结构，否则用linkedlist作为内部实现。</p><p>②Redis 3.2版本开始使用<strong>quicklist是</strong>zipList和linkedList的混合体，代替了ziplist和linkedlist(**双向循环列表)**，调高了内存管理效率。</p><p><strong>改用quicklist原因：</strong>链表的<strong>附加空间相对太高</strong>prev和next指针就要占去16个字节(64位系统的指针是8个字节), 另外每个节点的内存都是单独分配(加剧**内存的碎片化)**，影响内存管理效率。</p><p><strong>应用场景：</strong></p><p>①列表对象有序——&gt;做文章、商品等列表的存储。</p><p>②队列：lpush和rpop (查询并删除)第一个元素，消息队列。</p><p>③栈：1push 1pop</p><h1 id="3-哈希-Hash存储对象我也行-：key-map"><a href="#3-哈希-Hash存储对象我也行-：key-map" class="headerlink" title="3. 哈希(Hash存储对象我也行)：key : map"></a><strong>3.</strong> <strong>哈希(Hash存储对象我也行)：</strong>key : map</h1><p><strong>①两种实现方式</strong>：<strong>ziplist（压缩列表）， hashtable(哈希表)</strong></p><p><strong>②数据量小的时候</strong>：字典中保存的<strong>键值大小&lt; 64 字节</strong> 并且 字典中<strong>键值对个数&lt;512个</strong>。否则用hashtable来实现哈希对象。</p><p><img src="https://img-blog.csdnimg.cn/9a1ad0b852274775a7ae6627be465116.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5piv55yf55qE6I-c5ZWK5ZWK,size_17,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p><strong>应用场景：</strong></p><p>①字符串对象的很多功能使用哈希对象可以实现。如缓存用户信息的时候，使用Redis哈希对象存储，简单直观，如果使用合理可以减少内存空间的使用。<strong>缺点</strong>是hashtable会<strong>消耗更多内存</strong>。②购物车、计数器等功能。</p><h1 id="4-集合-Set标签系统我在行"><a href="#4-集合-Set标签系统我在行" class="headerlink" title="4. 集合(Set标签系统我在行)"></a><strong>4.</strong> <strong>集合(Set标签系统我在行)</strong></h1><p><strong>内部编码两种</strong>: 元素都是整数 且 元素个数&lt;512个使用intset编码，否则使用hashtable</p><p><strong>应用场景：</strong></p><p><strong>①</strong>无序、不可重复、支持并交差——&gt;可以用于标签系统。</p><p>②SPOP（随机移除并返回集合中一个或多个元素）和 SRANDMEMBER（随机返回集合中一个或多个元素）命令——&gt;可以实现抽奖系统。</p><h1 id="5-有序集合-ZSet排名我最棒-："><a href="#5-有序集合-ZSet排名我最棒-：" class="headerlink" title="5. **有序集合(ZSet排名我最棒)**："></a><strong>5.</strong> **有序集合(ZSet排名我最棒)**：</h1><p>Set + score(分值), <strong>ZSet****元素不重复但是分值可以重复</strong>，可以用于排序。</p><p><strong>存储结构：</strong>数据较少时,元素个数&lt;128个；元素长度&lt;64字节。用ziplist存储。否则用skiplist(跳表)存储。</p><p><strong>应用场景：</strong></p><p>①排行榜：网站用户点赞、播放排名、电商系统中商品销量排名等。</p><h1 id="6-压缩列表-zip1ist-：是列表和哈希的底层实现之一。"><a href="#6-压缩列表-zip1ist-：是列表和哈希的底层实现之一。" class="headerlink" title="6.压缩列表(zip1ist)：是列表和哈希的底层实现之一。"></a><strong>6.压缩列表(zip1ist)：是列表和哈希的底层实现之一。</strong></h1><p>  <strong>列表只包含少量列表项</strong>,并且每个列表项要么就是<strong>小整数值</strong>,要么就是<strong>长度比较短的字符串</strong>,那么Redis就会使用压缩列表来做<strong>List的底层实现</strong>。</p><p>  <strong>哈希只包含少量键值对</strong>, 并且每个键值对的<strong>键和值</strong>要么就是<strong>小整数值</strong>,要么就是<strong>长度比较短的字符串</strong>,那么Redis就会使用压缩列表来做<strong>Hash的底层实现</strong>。</p><p><img src="https://img-blog.csdnimg.cn/a827700e7e1743ad8242d87e765eada8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5piv55yf55qE6I-c5ZWK5ZWK,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h1 id="7-跳跃表-skiplist-：单链表-多级索引"><a href="#7-跳跃表-skiplist-：单链表-多级索引" class="headerlink" title="7. 跳跃表(skiplist)：单链表 + 多级索引"></a><strong>7.</strong> <strong>跳跃表(skiplist)：单链表 + 多级索引</strong></h1><p>如果一个有序集合元素数量<strong>比较多</strong> 或 元素成员是<strong>比较长</strong>的字符串时，Redis 就会<strong>使用跳跃表作为有序集合健的底层实现</strong>。</p><p><strong>特点：</strong></p><p>①跳跃表在链表的基础上增加了<strong>多级索引提升查找的效率</strong>，但其是一个<strong>空间换时间</strong>的方案，必然会带来一个问题-索引是占内存的。原始链表中存储的有可能是很大的对象，而<strong>索引结点只需要存储关键值和几个指针</strong>，<strong>优势会放大，缺点可忽略</strong>。</p><p>②跳跃表由<strong>zskiplist</strong>和<strong>zskiplist</strong>node两个结构组成，其中 <strong>zskiplist用于保存跳跃表信息</strong>（比如<strong>表头节点、表尾节点、长度</strong>），而<strong>zskiplistnode则用于表示跳跃表节点(层level、后退指针backward、分值score、成员对象oj)</strong></p><p>③Redis每个跳跃表<strong>节点的层高都是1至32</strong>之间的随机数</p><p>④在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。<strong>（分值可以重复，但元素不能重复）</strong></p><h1 id="8-快速列表-quicklist-："><a href="#8-快速列表-quicklist-：" class="headerlink" title="8.快速列表(quicklist)："></a><strong>8.快速列表(quicklist)：</strong></h1><p>Redis 3.2版本以后提出的，是 zipList 和 linkedList 的混合体，相对于链表它<strong>压缩了内存</strong>。<strong>即有链表的双向性质，又有ziplist高效的内存使用率</strong>。一个quicklistnode的数据由ziplist存储存储，<strong>新建一个ziplist就会新建一个quicklistnode节点。</strong></p><p><img src="https://img-blog.csdnimg.cn/4f08211833294ef49be96eae01c24b3c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5piv55yf55qE6I-c5ZWK5ZWK,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p><strong>插入</strong></p><p>**①头结点的头部或尾节点的尾部插入:**如果头节点(或尾节点)上ziplist大小没有超过限制, 那么新数据被直接插入到ziplist中（调用 ziplistPush ）。否则新创建一个quicklistNode节点(对应地也会新创建一个ziplist)</p><p><strong>②中间插入：</strong></p><p>1.没有超过插入位置所在ziplist的限制，直接插；</p><p>2.插入位置所在的ziplist超过了限制，并且插在ziplist两端，相邻quicklist的ziplist大小没有超过限制，插入相邻quicklist的ziplist</p><p>3.插入位置所在的ziplist超过限制，并且在ziplist两端，相邻的quicklist的ziplist大小超过了限制，新建一个quicklist然后插入到新建的quicklist的ziplist中</p><p>4.插入位置所在的ziplist超过限制，并且在ziplist中间插入，需要把ziplist分裂为两个节点，然后再在其中一个节点插入。</p><p><strong>②删除</strong></p><p><strong>③查找</strong></p><p>知道查找数据的index。我们需要先根据node的个数，找到对应的ziplist，调用ziplist的index就能成功找到。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis常用语法</title>
      <link href="/posts/33740.html"/>
      <url>/posts/33740.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-String"><a href="#1-String" class="headerlink" title="1. String"></a>1. String</h2><p>如果只使用redis中的字符串类型，且不使用redis的持久化功能，那么，redis就和memcache非常非常的像了。</p><p>字符串长度<strong>大于39字节</strong>的时候，使用<strong>简单动态字符串</strong>，对象编码为RAW。<strong>小于等于39字节</strong>的时候使用embstr编码格式保存为字符串。</p><p><strong>使用场景</strong></p><p>Value除了是字符串以外还可以是数字。</p><p>计数器、统计多单位的数量、粉丝数、<strong>对象缓存存储</strong>。</p><p><strong>用法：</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">set  k1  v1get  k1keys *   //查看所有keystrlen k1exists k1  //查看是否存在append k1 “asda”   //不存在就新建incr  k1  //自增decr k1  //自减incrby  k1  10   //步长10增加decrby  k1  10  //步长减少10incr操作具有原子操作的特性，可以用来实现原子计数。getrange k1  0 3 //截取字符串，闭区间[0,3]getrange k1  0  -1 //查看整个字符串setrange k1  1  xx  //替换指定位置开始的字符串，从下标1开始替换成xx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分布式锁中会使用</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">setex  k1 10  //设置k1  10s的过期时间setnx  mykey  “ myvalue” //不存在再设置ttl  k1  //查看k1剩余时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>批量设置和获取</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">mset  k1 v1  k2  v2  k3  v3mget  k1  k2  k3  //批量获取key的值msetnx k1 v1 k4 v4  //redis的事务不具有原子性但是操作具有原子性，msetnx要么全部成功要么全部回滚。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>对象user : {id} : {filed}</strong> </p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">set user :1 {name : zhangsen, age : 3 , sex : f}mset user : 1 : name  zhangsan  user : 1 : age 2mget  user : 1 : name   user:1:agegetset  k1  20   //先获取k1的值，再设置成20，不存在返回nil<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-List"><a href="#2-List" class="headerlink" title="2. List"></a>2. List</h2><p>lists的底层实现是<strong>链表</strong>，头部和尾部插入速度极快，但定位会比较慢。</p><p>key不存在，创建新的链表。移除了所有的值，空链表也是不存在。</p><p><strong>应用场景：</strong></p><ol><li><p>我们可以利用lists来实现一个<strong>消息队列（Lpush Rpop）（重点****）</strong>，而且可以确保先后顺序，不必像MySQL需要通过ORDER BY来进行排序。</p></li><li><p>利用LRANGE还可以很方便的实现<strong>分页</strong>的功能。</p></li><li><p>在博客系统中，每片<strong>博文的评论</strong>也可以存入一个<strong>单独的list</strong>中。</p></li><li><p>栈（Lpush Lpop）</p></li></ol><p><strong>插入</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">lpush   list  onelpush  list  twolpush  list three  //左边插入，头插lrange list  0 1  //返回[0,1]元素 这里返回的是three tworpush  list  right  //右边插入，插入尾部<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>移除</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">lpop  list //左边移除rpo  list   //右边移除lrem list  0  three  //移除指定下标的值，这里是移除下标为0的three<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修剪</strong></p><pre class="line-numbers language-none"><code class="language-none">ltrim  list  1  2  //截取指定下标范围的值，会改变list（原地操作）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>获取值</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">lindex  list  1  //通过下标获取值llen  list  //返回长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>不同list之间移动元素</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">rpoplpush  list   mylist  //移除list右边的第一个元素放到mylist左边第一个位置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>更新值</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">lset  list  1  newvalue  //修改指定下标的值，前提是存在这个list插入值linsert  list before  one   zero  //在one之前插入zerolinsert  list  after  three  four  //在three之后插入four<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Set"><a href="#3-Set" class="headerlink" title="3. Set"></a>3. Set</h2><p>集合中元素不重复，无序。</p><p>当集合元素都是整数，且数量不超过512个，用<strong>整数集合</strong>实现。否则<strong>用Hash表实现。</strong></p><p><strong>应用场景：</strong></p><p>QQ有一个社交功能叫做“好友标签”，大家可以给你的好友贴标签，比如“大美女”、“土豪”、“欧巴”等等，这时就可以使用redis的集合来实现，把每一个用户的标签都存储在一个集合之中。</p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">sadd   myset  hello  //增加元素smembers  myset  //查看集合成员sismember  myset word //查看元素是否属于一个集合<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>获取元素个数</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">scard  myset   //获取元素个数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>随机抽选</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">srandmember  myset  //随机抽选出指定个数的元素srandmember  myset  2  //随机选出2个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>删除</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">spop  myset  //随机删除srem  myset  hello   //指定删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>两个集合元素移动</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">smove  myset  myset2  hello  //将myset中的hello移动到myset2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>求差集</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">sdiff  myset  myset2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>求交集</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">sinter  myset  myset2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>求并集</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">sunion  myset  myset2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>应用场景：</strong></p><p>微博共同关注(并集)</p><h2 id="4-Hash"><a href="#4-Hash" class="headerlink" title="4. Hash"></a>4. Hash</h2><p>hashes存的是字符串和字符串值之间的映射，比如一个用户要存储其全名、姓氏、年龄等等，就很适合使用哈希。</p><p>当键值长度都小于<strong>64字节</strong>，且元素数量<strong>小于512个</strong>，使用<strong>压缩列表</strong>实现。否则用<strong>Hash表</strong>实现。</p><p><strong>Map****集合， key-&lt;key,value&gt;</strong>  这里的值是&lt;key,vlaue&gt;一个Map集合</p><p><strong>单值设置</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">hset  myhash  name  zhangsanhget  myhash  fileld1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>多值设置</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">hmset myhash  name lisi  age  15   // 设置多个键值hmget myhash name  age  //获取多个键值hgetall myhash   //获取所有的键值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">hdel  myhash  name   //删除指定fieldhlen  myhash   //获取field个数或者hash的长度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>判断是否存在</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">hexists  myhash  field1  //判断某个字段是否存在hkeys  myhash  //查看所有的field字段hvals   myhash  //获取所有field字段对应的值hincrby  muhash  field2  1 //对指定字段的值增加指定数值hsetnx  myhash field 2  newvalue  //如果不存在就设置为newvalue 已存在则不能设置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>应用：存储变动的信息，存储对象</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">hset  user : name  zhangsan  age  15  sex  female<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-Zset"><a href="#5-Zset" class="headerlink" title="5. Zset"></a>5. Zset</h2><p><strong>在set的基础上增加了一个score值。</strong></p><p><strong>字典+跳跃表实现：</strong></p><p><strong>字典：实现O(1)查找数据。跳跃表：实现有序操作。</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">set k1  v1zset k1 score v1zadd  salary  2500  zhangsan //添加一个值zadd  salary  45000  xiaohong    800  xiaoming   //添加多个值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>排序</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">zrangebyscore  salary   -inf   +inf zrangebyscore  salary  zrange  salary  -inf  +inf  withscores  //按照score升序排列，范围在-inf到+infzrange  salary  0  5000  withscores  //按照score升序排列，范围在0到5000zrevrangebyscore  salary  0  5000  withscores  //降序排列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">zrem salary zhangsan<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>获取有序集合元素的个数</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">zcard salary<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>统计两个区间的元素有多少个</strong></p><pre class="line-numbers language-Go" data-language="Go"><code class="language-Go">zcount  salary<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>应用场景：</strong></p><p>重要消息和普通消息</p><p>排行榜（播放量进行排序）</p><p>带权重判断</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis语法 </tag>
            
            <tag> redis数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信公众号控制ESP8266的LED</title>
      <link href="/posts/56473.html"/>
      <url>/posts/56473.html</url>
      
        <content type="html"><![CDATA[<h1 id="用微信公众号控制ESP8266的LED，进一步使用微信当遥控器（避免写APP或者IOS或者小程序），控制一切设备。"><a href="#用微信公众号控制ESP8266的LED，进一步使用微信当遥控器（避免写APP或者IOS或者小程序），控制一切设备。" class="headerlink" title="用微信公众号控制ESP8266的LED，进一步使用微信当遥控器（避免写APP或者IOS或者小程序），控制一切设备。"></a>用微信公众号控制ESP8266的LED，进一步使用微信当遥控器（避免写APP或者IOS或者小程序），控制一切设备。</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>官网教程<a href="https://iot.weixin.qq.com/wiki/new/index.html?page=5-5">微信硬件平台</a></p><p>成果演示<a href="https://www.bilibili.com/video/av53059083">B站投稿，欢迎三连</a></p><h2 id="功能架构图"><a href="#功能架构图" class="headerlink" title="功能架构图"></a>功能架构图</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/7a110082e6ae844b1d289f757e07213b.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/dc2135c4842823e3d706ce8922c428d6.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><hr><hr><h2 id="1-公众号注册"><a href="#1-公众号注册" class="headerlink" title="1 公众号注册"></a><strong>1 公众号注册</strong></h2><p>1.申请认证公众号&amp;开通设备功能1.1公众号申请：<a href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/81d08592c77f0ed214301a88f46bbf56.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>个人订阅号</strong>  </p><p>功能有限，不能有设备管理模块功能，本教程系列使用的是订阅号，做一个测试足够了。</p><p><strong>企业服务号</strong></p><p>注册必须要有公司信息，法人等组织代码，个人用不了。 某宝上可以买个临时用下测试。</p><p>可以拥有设备管理功能，简单来说可以生产100个设备（例如大气传感器），每个用户可以对应自己的设备</p><h2 id="2-搭建自己的服务器"><a href="#2-搭建自己的服务器" class="headerlink" title="2.搭建自己的服务器"></a><strong>2.搭建自己的服务器</strong></h2><p><strong>2.0购买云服务器</strong></p><p>服务器选择有很多，国内的腾讯云、阿里云、百度云等等，阿里云算是国内一家独大的了，但都价格较贵吧,最好用学生认证买，会便宜很多。</p><p><strong>2.1 服务器搭建</strong></p><p>第一种方案 腾讯云服务器搭， 必须报备后才能使用80端口网页服务功能，其实报备也很快。</p><p>第二种方案 就是找个外国的服务器，没有报备的限制。</p><p>2.2开放服务器端口</p><p> 和微信服务器交互，我们需要80或443端口，服务器端口默认需要开启，才能被外界访问。</p><p> <strong>第一层，登陆网页服务器管理界面添加安全组</strong></p><p>腾讯云如何添加安全组开放端口 参考教程 自己搜</p><h2 id="3-搭建Web服务器-apache-php-mysql"><a href="#3-搭建Web服务器-apache-php-mysql" class="headerlink" title="3 搭建Web服务器(apache + php + mysql)"></a>3 搭建Web服务器(apache + php + mysql)</h2><p>centos6系统下，搭建Web服务器(apache + php + mysql)</p><h3 id="3-0-安装apache"><a href="#3-0-安装apache" class="headerlink" title="3.0 安装apache"></a>3.0 安装apache</h3><p>安装yum install httpd</p><p>启动service httpd start</p><p>暂停service httpd stop</p><p>重启service httpd restart</p><p>检查开机启动情况chkconfig –list httpd</p><p>默认情况下是全部关闭的，<strong>尽量设置开机启动</strong>，以防主机意外关机</p><p>设置开机启动命令chkconfig httpd on</p><p>再次检查启动情况，看到2，3，4，5为启动</p><p>关闭开机启动命令chkconfig httpd off</p><p>到此Apache安装完成，在自己浏览器中输入主机IP和端口号能正常打开</p><p>（不能打开重启下服务器）</p><p>Apache的默认网站根目录</p><p>/var/www/html</p><p><img src="https://img-blog.csdnimg.cn/img_convert/69fa15d255bea11ffadf99461e86c85c.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>配置文件路径</p><p>/etc/httpd/conf/httpd.conf</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c8763c89c613a5c3082206c62e195143.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="3-1-安装php"><a href="#3-1-安装php" class="headerlink" title="3.1 安装php"></a>3.1 安装php</h3><p>yum install php</p><p>yum install php-mysql php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc</p><p>yum install php-mysql</p><p>以上命令为安装php及其支持的组件</p><p>测试是否安装成功</p><p>在这个文件夹下，创建一个info.php文件</p><p>vi /var/www/html/info.php</p><p>(不喜欢vi命令编辑的，可以把文件拖到windos上修改，后再复制过去)</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ac25fc5a89c1713f493be5b6fb905161.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1>It's work!</h1><!--?php  echo 'HELLO WORLD';  phpinfo();?--><p>重启Apache服务器</p><p>在浏览器地址栏访问：http://自己的服务器IP/info.php</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a752857345791dde554040ca349015d6.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="3-2安装mysql"><a href="#3-2安装mysql" class="headerlink" title="3.2安装mysql"></a>3.2安装mysql</h3><p>安装</p><p>首先查看主机是否已经安装</p><p>rpm -qa|grep mysql</p><p>注意：可能检查中安装有php-mysql XXXXX 和 mysql-libXXXX,这是刚刚第二步安装的php的组件,不必理会</p><p>已经安装的话就执行删除命令</p><p>yum remove mysql</p><p>rm -f /etc/my.cnf</p><p>然后继续安装</p><p>使用命令</p><p>yum list | grep mysql</p><p>来查看yum上提供的mysql数据库可下载的版本</p><p>安装命令</p><p>yum install -y mysql-server mysql mysql-devel</p><p>等待一段时间安装成功</p><p>配置</p><p>接下来是对mysql的配置(注意:命令中是”mysqld”,不是mysql)</p><p>初始化:</p><p>service mysqld start</p><p>重启:</p><p>service mysqld restart</p><p>配置开机自动启动:</p><p>chkconfig mysqld on</p><p>为mysql的root账户设置密码:</p><p>mysqladmin -u root password ‘*********’</p><p>改密码后要重启Mysql服务器</p><p>登录命令</p><p>mysql -u root -p</p><p>配置Apache使其支持PHP</p><p>教程<a href="https://blog.csdn.net/qq_25371579/article/details/78476186">CentOS6下Apache、MySql、PHP安装_MatrixSparse的博客-CSDN博客</a></p><p>需要在httpd.conf中添加以下代码，修改后重启Apache服务</p><p><img src="https://img-blog.csdnimg.cn/img_convert/07ec520756bfd33f1a5b06c5e83e3d08.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>把这个文件拖到windons上，修改</p><p><img src="https://img-blog.csdnimg.cn/img_convert/85025e77c2ab07429d05949f962fca3a.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>添加</p><p>LoadModule php5_module modules/libphp5.so</p><p>AddType application/x-httpd-php .php</p><p>AddType application/x-httpd-php-source .phps</p><p> 然后文件重新复制回去，修改后重启Apache服务</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e0df9e4213ee9bff07372311c25e01e6.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h3 id="3-3装MySql图形管理界面phpMyAdmin"><a href="#3-3装MySql图形管理界面phpMyAdmin" class="headerlink" title="3.3装MySql图形管理界面phpMyAdmin"></a>3.3装MySql图形管理界面phpMyAdmin</h3><p>从官网上下载下来（注意版本号，看是否支持本机的MySql和PHP），直接放在网站根目录下，在浏览器中输入相应的地址就可以访问，登陆后即可管理</p><p><a href="https://blog.csdn.net/programmer_wei/article/details/45888835">CentOS6.5 配置LAMP（Apache+MySQL+PHP）环境，并配置phpmyadmin_oo笨小孩oo的博客-CSDN博客</a></p><p>\1. #安装phpmyadmin </p><p>\2. yum -y install phpmyadmin  </p><p>\3. yum install php-mcrypt</p><p>phpmyadmin默认只能使用<a href="http://localhost/phpmyadmin%E6%9D%A5%E8%AE%BF%E9%97%AE%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9/etc/httpd/conf.d/phpmyadmin.conf%E4%B8%AD%E5%AF%B9%E5%BA%94%E9%83%A8%E5%88%86%E4%B8%BA">http://localhost/phpmyadmin来访问，可以修改/etc/httpd/conf.d/phpmyadmin.conf中对应部分为</a></p><p>\1. &lt;Directory “/usr/share/phpmyadmin”&gt; </p><p>\2. Order Deny,Allow </p><p>\3. # Deny from all </p><p>\4. Allow from All </p><p>\5.  </p><p>phpMyAdmin 的默认安装目录是/usr/share/phpMyAdmin，同时会在 Apache 的配置文件目录中自动创建虚拟主机配置文件/etc/httpd/conf.d/phpMyAdmin.conf（区分大小写）。</p><p>vi /etc/httpd/conf.d/phpmyadmin.conf</p><p>#Alias /phpMyAdmin /usr/share/phpMyAdmin</p><p>#Alias /phpmyadmin /usr/share/phpMyAdmin</p><p>里面的</p><p>Require ip 127.0.0.1</p><p>Require ip ::1</p><p>改成 Require all granted</p><p>为该目录创建符号连接到 phpMyAdmin 安装目录（/usr/share/phpMyAdmin）：</p><p>ln -sf /usr/share/phpMyAdmin /var/www/html/phpmyadmin</p><p>[root@localhost ~]# service httpd restart</p><p>测试，在网页里输入自己的服务器的IP，自动跳转php测试样例</p><p><a href="http://localhost/phpmyadmin">http://localhost/phpmyadmin</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2e68887814b7675f2e43afa8bc99aa90.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="4-配置微信SDK"><a href="#4-配置微信SDK" class="headerlink" title="4 配置微信SDK"></a>4 配置微信SDK</h2><p><strong>4.1 下载SDK 以及 arduino代码</strong></p><p>链接：<a href="https://pan.baidu.com/s/1aBqb_dLQ3bWbFmaaXk3xvQ">百度网盘-链接不存在</a></p><p>提取码：29vy</p><p><img src="https://img-blog.csdnimg.cn/img_convert/406cba3a0af23e06e9259d0debf602e7.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>4.2 将SDK放在服务器下</strong></p><p>注意路径，后面配置微信公众号需要用到，不能出错。</p><p>/var/www/html/WeChat</p><p><img src="https://img-blog.csdnimg.cn/img_convert/db44acb06ea4bab4774e4ed53e0ff831.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="5-配置微信公众号"><a href="#5-配置微信公众号" class="headerlink" title="5 配置微信公众号"></a>5 配置微信公众号</h2><p> <strong>5.1 个人申请订阅号做的测试</strong></p><p>公众号申请：<a href="https://mp.weixin.qq.com/">https://mp.weixin.qq.com</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c390dfd83d813f8ce3a1565fdad17d00.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>订阅号是不用交钱的，就目前我们控制LED订阅号是足够了的</p><p><strong>5.2 订阅号公众号设置</strong></p><p>公众号申请好之后登陆，然后进行开发者设置。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/20d44fce09f7f0f70106838d1ada8a05.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/056f33b595722795e6b1e3d10613d232.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>5.3 说明：</strong></p><p>服务器路径一定要填写对，是微信SDK文件下的的index.php</p><p>/var/www/html/WeChat</p><p>对应填写 ： 服务器IP+/WeChat/index.php</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3ca3b7afa725244b89a1522444e516f8.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 不是/var/www/html/下面的index.php(安装网页服务器的测试网页)</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d92fb6561abb19fd8dce82909f44629d.png" alt="img"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>根据实际的sdk路径填写地址，看上图填写完成之后就点击提交，不出意外就<strong>显示提交成功</strong></p><h2 id="6-测试"><a href="#6-测试" class="headerlink" title="6 测试"></a>6 测试</h2><p>打开微信，关注自己的公众号</p>]]></content>
      
      
      <categories>
          
          <category> 物联网平台 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ESP8266 </tag>
            
            <tag> 微信公众号开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-vue-theme Theme introduction</title>
      <link href="/posts/48455.html"/>
      <url>/posts/48455.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-Hello-World"><a href="#title-Hello-World" class="headerlink" title="title: Hello World"></a>title: Hello World</h2><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多版本并发控制</title>
      <link href="/posts/54020.html"/>
      <url>/posts/54020.html</url>
      
        <content type="html"><![CDATA[<h2 id="并发一致性问题："><a href="#并发一致性问题：" class="headerlink" title="并发一致性问题："></a>并发一致性问题：</h2><p><strong>1. 丢失修改:</strong></p><p><strong>2. 读脏数据:</strong> </p><p>事务A读取事务B未提交的修改，事务B之后进行了回滚。</p><p><strong>3. 不可重复读：</strong></p><p>事务A读取了事务B未提交的修改。一个事务读取了另外一个事务 <strong>修改</strong> 后记录 强调的是 <strong>update 和delete</strong> , 只需要锁住满足条件的记录即可。</p><p><strong>4. 幻读：</strong></p><p>一个事务读取了另外一个事务<strong>插入</strong>的数据，强调的是 <strong>insert</strong> ，要锁住满足条件及相近的记录。</p><p>MYSQL 中默认的隔离级别是可重复读，可解决脏读和不可重复读的问题。但是不能解决幻读的问题。 Oracle 默认的是Read Commit 读已提交，可以避免脏读的问题。</p><h3 id="幻读是因为update的操作的where是属于当前读，所以与快照读无关，从而导致了update修改的数据的版本号也被更新为了当前的版本号（可能存在低的事务版本号覆盖高的事务版本号），然后update后续的查询就能查询到了其他高版本事务提交后的数据了；主要的原因还是因为update当前读数据再不同事务中冲突导致，所以解决思路也是如何避免此冲突，通常是加行锁"><a href="#幻读是因为update的操作的where是属于当前读，所以与快照读无关，从而导致了update修改的数据的版本号也被更新为了当前的版本号（可能存在低的事务版本号覆盖高的事务版本号），然后update后续的查询就能查询到了其他高版本事务提交后的数据了；主要的原因还是因为update当前读数据再不同事务中冲突导致，所以解决思路也是如何避免此冲突，通常是加行锁" class="headerlink" title="幻读是因为update的操作的where是属于当前读，所以与快照读无关，从而导致了update修改的数据的版本号也被更新为了当前的版本号（可能存在低的事务版本号覆盖高的事务版本号），然后update后续的查询就能查询到了其他高版本事务提交后的数据了；主要的原因还是因为update当前读数据再不同事务中冲突导致，所以解决思路也是如何避免此冲突，通常是加行锁"></a>幻读是因为update的操作的where是属于当前读，所以与快照读无关，从而导致了update修改的数据的版本号也被更新为了当前的版本号（可能存在低的事务版本号覆盖高的事务版本号），然后update后续的查询就能查询到了其他高版本事务提交后的数据了；主要的原因还是因为update当前读数据再不同事务中冲突导致，所以解决思路也是如何避免此冲突，通常是加行锁</h3><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="1-MVCC"><a href="#1-MVCC" class="headerlink" title="1. MVCC"></a><strong>1. MVCC</strong></h2><p>MVCC 的英文全称是 Multiversion Concurrency Control ，中文意思是<strong>多版本并发控制技术</strong>。原理是，通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本。可以通过<strong>比较版本号决定数据是否显示出来</strong>。读取数据的时候不需要加锁可以保证事务的隔离效果。</p><p><strong>备注：</strong></p><p>MYSQL 中默认的隔离级别是<strong>可重复读</strong>，可<strong>解决脏读和不可重复读</strong>的问题。但是<strong>不能解决幻读</strong>的问题。 Oracle 默认的是Read Commit 读已提交，可以避免脏读的问题。</p><h2 id="2-解决什么问题？"><a href="#2-解决什么问题？" class="headerlink" title="2. 解决什么问题？"></a><strong>2. 解决什么问题？</strong></h2><p>一般解决不可重复读 和 幻读问题，是采用锁机制实现，有没有一种<strong>乐观锁</strong>的问题去处理，可以采用 MVCC 机制的设计，可以用来解决这个问题。取代 行锁，降低系统开销。</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h2 id="3-优点或解决什么问题？"><a href="#3-优点或解决什么问题？" class="headerlink" title="3.优点或解决什么问题？"></a><strong>3.优点或解决什么问题？</strong></h2><ul><li>读写不阻塞，读旧版本的快照，写最新版本的快照。提升数据并发处理能力。</li><li>降低了死锁的概率， MVCC 采用乐观锁，读取数据时，不需要加锁，写操作，只需要锁定必要的行。</li><li>解决了一致性读的问题，当我们朝向某个数据库在时间点的快照是，只能看到这个时间点之前事务提交更新的结果，不能看到时间点之后事务提交的更新结果。</li></ul><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="4-快照读与当前读？"><a href="#4-快照读与当前读？" class="headerlink" title="4.快照读与当前读？"></a><strong>4.快照读与当前读？</strong></h2><p><strong>快照读：</strong></p><p>读取的是<strong>快照数据</strong>，不加锁的简单 Select 都属于快照读.</p><p><strong>当前读：</strong></p><p>读的是<strong>最新数据，</strong>而不是历史的数据，加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><h2 id="5-InnoDB-的-MVCC-是如何实现的？"><a href="#5-InnoDB-的-MVCC-是如何实现的？" class="headerlink" title="5. InnoDB 的 MVCC 是如何实现的？"></a><strong>5. InnoDB 的 MVCC 是如何实现的？</strong></h2><p>InnoDB 是如何存储记录多个版本的？这些数据是 <strong>事务版本号</strong>，<strong>行记录中的隐藏列和Undo Log</strong>。</p><h3 id="事务版本号"><a href="#事务版本号" class="headerlink" title="事务版本号"></a><strong>事务版本号</strong></h3><p>每开启一个日志，都会从数据库中获得一个<strong>事务ID</strong>（也称为<strong>事务版本号</strong>），这个事务 ID 是自增的，通过 ID 大小，可以判断事务的<strong>时间顺序</strong>。</p><h3 id="行记录的隐藏列"><a href="#行记录的隐藏列" class="headerlink" title="行记录的隐藏列"></a><strong>行记录的隐藏列</strong></h3><ol><li><strong>row_id :</strong> 隐藏的行 ID ,用来生成默认的<strong>聚集索引</strong>。如果创建数据表时没指定聚集索引，这时 InnoDB 就会用这个隐藏 ID 来创建聚集索引。采用聚集索引的方式可以提升数据的<strong>查找效率</strong>。</li><li><strong>trx_id :</strong> 操作这个数据事务 ID ，也就是最后一个对数据插入或者更新的事务 ID 。</li><li><strong>roll_ptr :</strong> 回滚指针，指向这个记录的 Undo Log 信息。</li></ol><p><img src="https://img-blog.csdnimg.cn/13c91af5753d42dea82b84898bd41acd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5piv55yf55qE6I-c5ZWK5ZWK5ZWK,size_18,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><h3 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a><strong>Undo Log</strong></h3><p>InnoDB 将<strong>行记录快照保存在 Undo Log</strong> 里。</p><p><img src="https://img-blog.csdnimg.cn/1dc55cd00b6345809368429bfd5197cc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR5piv55yf55qE6I-c5ZWK5ZWK5ZWK,size_19,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p> 数据行通过快照记录都通过链表的结构的串联了起来，<strong>每个快照都保存了 trx_id 事务ID</strong>，如果要找到历史快照，就可以通过<strong>遍历回滚指针</strong>的方式进行查找。</p><h2 id="Read-View-是啥？"><a href="#Read-View-是啥？" class="headerlink" title="Read View 是啥？"></a><strong>Read View 是啥？</strong></h2><p>如果一个事务要<strong>查询行记录</strong>，需要读取哪个版本的行记录呢？ Read View 就是来解决这个问题的。Read View 可以帮助我们<strong>解决可见性问题</strong>。 Read View 保存了<strong>当前事务开启时所有活跃的事务列表</strong>。换个角度，可以理解为: <strong>Read View 保存了不应该让这个事务看到的其他事务 ID 列表。</strong></p><ol><li><strong>trx_ids：</strong>系统当前<strong>正在活跃的事务ID集合</strong>。</li><li><strong>low_limit_id ：</strong>活跃事务的最大的事务 ID。</li><li><strong>up_limit_id ：</strong>活跃的事务中最小的事务 ID。</li><li><strong>creator_trx_id：</strong>创建这个 ReadView 的事务ID。</li></ol><p>如果<strong>当前事务的 creator_trx_id 想要读取某个行记录</strong>，这个行记录ID 的trx_id ，这样会有以下的情况：</p><ul><li>如果 trx_id &lt; 活跃的<strong>最小</strong>事务ID（up_limit_id）,也就是说这个行记录在<strong>这些活跃的事务创建前就已经提交了，</strong>那么这个行记录对当前事务是<strong>可见的。</strong></li><li>如果trx_id &gt; 活跃的<strong>最大</strong>事务ID（low_limit_id），这个说明行记录在这些活跃的事务之后才创建，说明这个行记录对当前事务是<strong>不可见的。</strong></li><li>如果 up_limit_id &lt;= trx_id &lt;= low_limit_id, 说明该记录在 trx_ids 集合中，可能还处于活跃状态，因此我们需要在 trx_ids 集合中遍历 ，如果trx_id <strong>存在于 trx_ids 集合中</strong>，证明这个事务 trx_id 还处于<strong>活跃状态，不可见</strong>，否则 ，trx_id 不存在于 trx_ids 集合中，说明事务trx_id 已经提交了，这行记录是可见的。</li></ul><h2 id="如何查询一条记录"><a href="#如何查询一条记录" class="headerlink" title="如何查询一条记录"></a><strong>如何查询一条记录</strong></h2><ol><li>获取事务自己的版本号，即 <strong>事务ID</strong></li><li>获取 Read View</li><li>查询得到的数据的快照，然后与 Read View 中的事务版本号进行比较。</li><li>如果<strong>不符合 ReadView 规则</strong>， 那么就需要 Undo Log 中<strong>历史快照</strong>；</li><li>最后返回符合规则的数据</li></ol><p>InnoDB 实现多版本控制 （MVCC）是通过 <strong>ReadView+ UndoLog</strong> 实现的，UndoLog 保存了历史快照，ReadView 规则帮助判断当前版本的数据是否可见。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>如果事务隔离级别是 <strong>ReadCommit</strong> ，一个事务的每一次 Select 都会去查一次ReadView ，每次查询的Read View 不同，就可能会造成不可重复读或者幻读的情况。</li><li>如果事务的隔离级别是<strong>可重读</strong>，为了避免不可重读读，一个事务只在第一次 Select 的时候会获取一次Read View ，然后后面索引的Select 会复用这个 ReadView.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MVCC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
